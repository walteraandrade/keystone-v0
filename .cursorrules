# Keystone Audit Knowledge Graph - AI Assistant Rules

## Core Principles (Non-Negotiable)

### 1. Authority of truth

The graph database is the sole source of audit truth.

All entities, relationships, versions, and conclusions must be represented explicitly in the graph.

No fact, relationship, or conclusion may exist only in text, embeddings, or inference.

### 2. Role of vectors

Vector embeddings are auxiliary and non-authoritative.

Vector data is used only for semantic retrieval and context lookup.

Vector records must always reference graph node IDs.

Removing the vector database must not invalidate any audit conclusion.

### 3. Role of AI

AI agents may propose candidate entities, properties, and relationships.

AI agents must never assign IDs, persist data, or make final decisions.

All AI outputs are provisional and must be validated by deterministic system logic.

### 4. Provenance and traceability

Every persisted entity and relationship must be traceable to a source document and a specific location (page, section, row).

Versioning must preserve historical truth; nothing is overwritten or silently updated.

### 5. Modeling over convenience

Prefer explicit entities and relationships over implicit or derived meaning.

Avoid collapsing distinct concepts into generic blobs or documents.

If a relationship matters in an audit explanation, it must exist in the graph.

### 6. Explainability constraint

Any audit conclusion must be explainable without referencing embeddings, similarity scores, or AI behavior.

The system must be defensible to a human auditor or regulator.

### 7. Scope discipline

Focus on ingestion, normalization, and storage.

Do not introduce UI concerns, advanced search, or speculative features unless explicitly requested.

### 8. Implementation style

Prefer a functional programming style: immutable data, pure functions where possible, explicit data flow.

Avoid comments in code unless using JSDoc-style documentation for workflows that require additional context.

Code clarity should come from structure and naming, not inline commentary.

When making design or implementation decisions, prioritize:
correctness → traceability → explainability → extensibility, in that order.

If a proposed solution violates any rule above, it must be rejected or revised.

## Ontology v1.1.0 Additions

### Entities

- **ProcedureStep**: Operational procedure step (business key: `stepNumber + processId`)
  - Properties: `stepNumber`, `processId`, `description`, `responsibleRole?`, `frequency?`, `evidence?`
  - Links controls to operational procedures

### Relationships

- **IMPLEMENTS**: ProcedureStep → Control (links procedure steps to controls they implement)
- **APPLIED_IN**: Control → ProcedureStep (reverse relationship)
- **RelationshipStatus**: Optional field on all relationships
  - `SUGGESTED` - AI-proposed, awaiting confirmation
  - `CONFIRMED` - Human-validated
  - `null` - Legacy (pre-v1.1.0)

### New Services (v1.1.0)

- **BunSQLiteService**: Logs LLM extraction outputs to SQLite for debugging/audit trail
- **CleanupService**: Removes failed documents older than N hours
- **CoverageQueryRegistry**: Predefined queries for audit coverage gaps
  - `risks-without-controls`: Risks without mitigating controls
  - `controls-without-steps`: Controls without procedure steps
  - `unmitigated-high-rpn`: High RPN failure modes without mitigation

## Code Style Preferences

- Use TypeScript strict mode
- Prefer interfaces over types for public APIs
- Use dependency injection via constructor parameters
- Depend on interfaces, not concrete implementations
- Keep functions pure when possible
- Use explicit error types (GraphPersistenceError, ValidationError, etc.)
- Avoid magic numbers/strings (use constants or enums)

## Testing Conventions

- Unit tests: Mock dependencies via interfaces
- Integration tests: Use real database connections
- Run `bun run build` before marking implementation complete
- Phase validation: Use `bun run validate:phaseN` at phase boundaries

## Documentation Maintenance Rules

When modifying the codebase, update documentation as follows:

1. **New entity/relationship** → update `docs/DOMAIN_MODEL.md` AND `docs/ONTOLOGY_VERSIONING.md`
2. **New endpoint** → update `docs/API.md`
3. **New design pattern** → update `docs/DESIGN_PATTERNS.md` AND corresponding `src/**/README.md`
4. **Config changes** → update `docs/DEVELOPMENT.md`
5. **Architecture changes** → update `docs/ARCHITECTURE.md`
6. **README.md should NEVER contain implementation details** - keep it minimal (description, quickstart, links)

## Design Patterns

The codebase uses established patterns:

- **Strategy Pattern**: Document segmentation (`src/services/chunking/strategies/`)
- **Factory Pattern**: LLM service creation (`src/services/llm/LLMServiceFactory.ts`)
- **Repository Pattern**: Graph and vector data access (`src/services/graph/`, `src/services/vector/`)
- **Facade Pattern**: Hybrid query coordination (`src/services/query/HybridQueryService.ts`)
- **Dependency Injection**: Constructor-based wiring in `src/index.ts`

See `docs/DESIGN_PATTERNS.md` for details.

## Project Structure

```
src/
├── api/              # Fastify routes, handlers, schemas
├── config/           # Environment config with Zod validation
├── domain/           # Entity and relationship types
├── services/         # Business logic (graph, vector, llm, chunking, ingestion, query)
└── utils/           # Logger, errors, UUID
```

## Key Files

- `src/index.ts` - Composition root (dependency injection)
- `src/services/ingestion/IngestionOrchestrator.ts` - Main ingestion pipeline
- `src/services/graph/Neo4jRepository.ts` - Graph persistence
- `src/services/query/HybridQueryService.ts` - Hybrid query coordination
- `docs/ARCHITECTURE.md` - System overview and design decisions


